[{"content":"Markov Chain Prediction Algorithm\nWelcome to this tutorial on the Markov Chain Prediction Algorithm! In this post, we\u0026rsquo;ll break down its concepts step by step, using simple language and visual aids. By the end, you\u0026rsquo;ll have implemented a practical example of Markov Chains predicting probabilities for real-world decisions.\nWhat is a Markov Chain? A Markov Chain is a mathematical model that describes a system transitioning between states with certain probabilities. Its defining feature is the Markov Property, which states: \u0026ldquo;The future state depends only on the current state, not on the sequence of states that preceded it.\u0026rdquo;\nMathematically, this is expressed as:\n[ P(X_{t+1} = s_j | X_t = s_i, X_{t-1}, \u0026hellip;, X_0) = P(X_{t+1} = s_j | X_t = s_i) ]\nState Transition Probability Matrix The heart of a Markov Chain is the state transition probability matrix, which defines the probabilities of moving between states. Here\u0026rsquo;s an example for a three-state system (( s_1, s_2, s_3 )):\n[ P = \\begin{bmatrix} 0.7 \u0026amp; 0.2 \u0026amp; 0.1 \\ 0.3 \u0026amp; 0.4 \u0026amp; 0.3 \\ 0.2 \u0026amp; 0.3 \u0026amp; 0.5 \\end{bmatrix} ]\nA visual representation of state transitions might look like this:\nEach row represents the probability distribution for the current state transitioning to other states. For example, the probability of transitioning from ( s_1 ) to ( s_2 ) is 0.2. The rows must sum to 1, as they represent probability distributions.\nInitial State Distribution Before predicting future states, we need an initial state distribution ( \\pi ), for example:\n[ \\pi = [1.0, 0.0, 0.0] ]\nThis means the system starts entirely in state ( s_1 ).\nPrediction Formula The key formula for predicting future states is:\n[ \\pi^{(t+1)} = \\pi^{(t)} \\cdot P ]\nThis means we multiply the current state distribution ( \\pi^{(t)} ) by the state transition matrix ( P ) to get the next state distribution ( \\pi^{(t+1)} ). Repeating this process predicts future states.\nPractical Example: Decision Making Imagine you\u0026rsquo;re deciding what to do tomorrow. You have three choices:\nEat out (state ( s_1 )). Go for a walk (state ( s_2 )). Grab coffee (state ( s_3 )). You estimate the probabilities for transitions based on your preferences. For example:\nIf you eat out today, there\u0026rsquo;s a 70% chance you\u0026rsquo;ll eat out again tomorrow, a 20% chance you\u0026rsquo;ll go for a walk, and a 10% chance you\u0026rsquo;ll grab coffee. If you go for a walk today, there\u0026rsquo;s a 30% chance you\u0026rsquo;ll eat out, 40% chance you\u0026rsquo;ll go for another walk, and 30% chance you\u0026rsquo;ll grab coffee. If you grab coffee today, there\u0026rsquo;s a 20% chance you\u0026rsquo;ll eat out, 30% chance you\u0026rsquo;ll go for a walk, and 50% chance you\u0026rsquo;ll grab coffee again. Here\u0026rsquo;s the state transition matrix for this scenario:\n[ P = \\begin{bmatrix} 0.7 \u0026amp; 0.2 \u0026amp; 0.1 \\ 0.3 \u0026amp; 0.4 \u0026amp; 0.3 \\ 0.2 \u0026amp; 0.3 \u0026amp; 0.5 \\end{bmatrix} ]\nStarting with an initial state where you ate out today ( \\pi = [1.0, 0.0, 0.0] ), let\u0026rsquo;s predict what you\u0026rsquo;ll most likely do over the next few days.\nPython Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import numpy as np # Define the state transition matrix P = np.array([ [0.7, 0.2, 0.1], [0.3, 0.4, 0.3], [0.2, 0.3, 0.5] ]) # Define the initial state (starting with eating out) initial_state = np.array([1.0, 0.0, 0.0]) # Function to predict future states def predict_markov_chain(P, initial_state, steps): state = initial_state predictions = [] for step in range(steps): state = np.dot(state, P) predictions.append(state) print(f\u0026#34;Step {step + 1}: {state}\u0026#34;) return predictions # Run the prediction for 10 steps steps = 10 predicted_states = predict_markov_chain(P, initial_state, steps) print(\u0026#34;Predicted State Distribution After 10 Steps:\u0026#34;, predicted_states[-1]) Example Output Using the above code, you can predict what you\u0026rsquo;ll most likely do tomorrow and the days after. For example:\n1 2 3 4 5 Step 1: [0.7 0.2 0.1] Step 2: [0.58 0.28 0.14] Step 3: [0.494 0.318 0.188] ... Step 10: [0.4 0.3 0.3] This means by the 10th day, you\u0026rsquo;re equally likely to eat out, go for a walk, or grab coffee!\nConclusion Markov Chains offer a simple yet powerful framework for modeling state transitions in various contexts, from daily decision-making to weather forecasting. Try tweaking the probabilities or initial states to see how the outcomes change!\n","date":"2024-11-29T11:44:31+08:00","permalink":"https://CarlossQAQ.github.io/p/marcov_chain_prediction_algorithm/","title":"Marcov_chain_prediction_algorithm"},{"content":" Supplementary code for the Build a Large Language Model From Scratch book by Sebastian Raschka\nCode repository: https://github.com/rasbt/LLMs-from-scratch\nChapter 2: Working with Text Packages that are being used in this notebook:\nThis chapter covers data preparation and sampling to get input data \u0026ldquo;ready\u0026rdquo; for the LLM 2.1 Understanding word embeddings No code in this section\nThere are many forms of embeddings; we focus on text embeddings in this book LLMs work with embeddings in high-dimensional spaces (i.e., thousands of dimensions)\nSince we can\u0026rsquo;t visualize such high-dimensional spaces (we humans think in 1, 2, or 3 dimensions), the figure below illustrates a 2-dimensional embedding space 2.2 Tokenizing text In this section, we tokenize text, which means breaking text into smaller units, such as individual words and punctuation characters Load raw text we want to work with\nThe Verdict by Edith Wharton is a public domain short story\n(If you encounter an ssl.SSLCertVerificationError when executing the previous code cell, it might be due to using an outdated Python version; you can find more information here on GitHub)\nThe goal is to tokenize and embed this text for an LLM\nLet\u0026rsquo;s develop a simple tokenizer based on some simple sample text that we can then later apply to the text above\nThe following regular expression will split on whitespaces\nWe don\u0026rsquo;t only want to split on whitespaces but also commas and periods, so let\u0026rsquo;s modify the regular expression to do that as well\nAs we can see, this creates empty strings, let\u0026rsquo;s remove them\nThis looks pretty good, but let\u0026rsquo;s also handle other types of punctuation, such as periods, question marks, and so on\nThis is pretty good, and we are now ready to apply this tokenization to the raw text Let\u0026rsquo;s calculate the total number of tokens\n2.3 Converting tokens into token IDs Next, we convert the text tokens into token IDs that we can process via embedding layers later From these tokens, we can now build a vocabulary that consists of all the unique tokens\nBelow are the first 50 entries in this vocabulary:\nBelow, we illustrate the tokenization of a short sample text using a small vocabulary: Putting it now all together into a tokenizer class\nThe encode function turns text into token IDs\nThe decode function turns token IDs back into text We can use the tokenizer to encode (that is, tokenize) texts into integers\nThese integers can then be embedded (later) as input of/for the LLM\nWe can decode the integers back into text\n2.4 Adding special context tokens It\u0026rsquo;s useful to add some \u0026ldquo;special\u0026rdquo; tokens for unknown words and to denote the end of a text Some tokenizers use special tokens to help the LLM with additional context\nSome of these special tokens are\n[BOS] (beginning of sequence) marks the beginning of text\n[EOS] (end of sequence) marks where the text ends (this is usually used to concatenate multiple unrelated texts, e.g., two different Wikipedia articles or two different books, and so on)\n[PAD] (padding) if we train LLMs with a batch size greater than 1 (we may include multiple texts with different lengths; with the padding token we pad the shorter texts to the longest length so that all texts have an equal length)\n[UNK] to represent words that are not included in the vocabulary\nNote that GPT-2 does not need any of these tokens mentioned above but only uses an \u0026lt;|endoftext|\u0026gt; token to reduce complexity\nThe \u0026lt;|endoftext|\u0026gt; is analogous to the [EOS] token mentioned above\nGPT also uses the \u0026lt;|endoftext|\u0026gt; for padding (since we typically use a mask when training on batched inputs, we would not attend padded tokens anyways, so it does not matter what these tokens are)\nGPT-2 does not use an \u0026lt;UNK\u0026gt; token for out-of-vocabulary words; instead, GPT-2 uses a byte-pair encoding (BPE) tokenizer, which breaks down words into subword units which we will discuss in a later section\nWe use the \u0026lt;|endoftext|\u0026gt; tokens between two independent sources of text: Let\u0026rsquo;s see what happens if we tokenize the following text:\nThe above produces an error because the word \u0026ldquo;Hello\u0026rdquo; is not contained in the vocabulary\nTo deal with such cases, we can add special tokens like \u0026quot;\u0026lt;|unk|\u0026gt;\u0026quot; to the vocabulary to represent unknown words\nSince we are already extending the vocabulary, let\u0026rsquo;s add another token called \u0026quot;\u0026lt;|endoftext|\u0026gt;\u0026quot; which is used in GPT-2 training to denote the end of a text (and it\u0026rsquo;s also used between concatenated text, like if our training datasets consists of multiple articles, books, etc.)\nWe also need to adjust the tokenizer accordingly so that it knows when and how to use the new \u0026lt;unk\u0026gt; token Let\u0026rsquo;s try to tokenize text with the modified tokenizer:\n2.5 BytePair encoding GPT-2 used BytePair encoding (BPE) as its tokenizer\nit allows the model to break down words that aren\u0026rsquo;t in its predefined vocabulary into smaller subword units or even individual characters, enabling it to handle out-of-vocabulary words\nFor instance, if GPT-2\u0026rsquo;s vocabulary doesn\u0026rsquo;t have the word \u0026ldquo;unfamiliarword,\u0026rdquo; it might tokenize it as [\u0026ldquo;unfam\u0026rdquo;, \u0026ldquo;iliar\u0026rdquo;, \u0026ldquo;word\u0026rdquo;] or some other subword breakdown, depending on its trained BPE merges\nThe original BPE tokenizer can be found here: https://github.com/openai/gpt-2/blob/master/src/encoder.py\nIn this chapter, we are using the BPE tokenizer from OpenAI\u0026rsquo;s open-source tiktoken library, which implements its core algorithms in Rust to improve computational performance\nI created a notebook in the ./bytepair_encoder that compares these two implementations side-by-side (tiktoken was about 5x faster on the sample text)\nBPE tokenizers break down unknown words into subwords and individual characters: 2.6 Data sampling with a sliding window We train LLMs to generate one word at a time, so we want to prepare the training data accordingly where the next word in a sequence represents the target to predict: For each text chunk, we want the inputs and targets\nSince we want the model to predict the next word, the targets are the inputs shifted by one position to the right\nOne by one, the prediction would look like as follows:\nWe will take care of the next-word prediction in a later chapter after we covered the attention mechanism\nFor now, we implement a simple data loader that iterates over the input dataset and returns the inputs and targets shifted by one\nInstall and import PyTorch (see Appendix A for installation tips)\nWe use a sliding window approach, changing the position by +1:\n- Create dataset and dataloader that extract chunks from the input text dataset - Let's test the dataloader with a batch size of 1 for an LLM with a context size of 4: - An example using stride equal to the context length (here: 4) as shown below: - We can also create batched outputs Note that we increase the stride here so that we don\u0026rsquo;t have overlaps between the batches, since more overlap could lead to increased overfitting 2.7 Creating token embeddings The data is already almost ready for an LLM\nBut lastly let us embed the tokens in a continuous vector representation using an embedding layer\nUsually, these embedding layers are part of the LLM itself and are updated (trained) during model training Suppose we have the following four input examples with input ids 2, 3, 5, and 1 (after tokenization):\nFor the sake of simplicity, suppose we have a small vocabulary of only 6 words and we want to create embeddings of size 3:\nThis would result in a 6x3 weight matrix:\nFor those who are familiar with one-hot encoding, the embedding layer approach above is essentially just a more efficient way of implementing one-hot encoding followed by matrix multiplication in a fully-connected layer, which is described in the supplementary code in ./embedding_vs_matmul\nBecause the embedding layer is just a more efficient implementation that is equivalent to the one-hot encoding and matrix-multiplication approach it can be seen as a neural network layer that can be optimized via backpropagation\nTo convert a token with id 3 into a 3-dimensional vector, we do the following:\nNote that the above is the 4th row in the embedding_layer weight matrix\nTo embed all four input_ids values above, we do\nAn embedding layer is essentially a look-up operation: You may be interested in the bonus content comparing embedding layers with regular linear layers: ../03_bonus_embedding-vs-matmul\n2.8 Encoding word positions Embedding layer convert IDs into identical vector representations regardless of where they are located in the input sequence: Positional embeddings are combined with the token embedding vector to form the input embeddings for a large language model: The BytePair encoder has a vocabulary size of 50,257:\nSuppose we want to encode the input tokens into a 256-dimensional vector representation:\nIf we sample data from the dataloader, we embed the tokens in each batch into a 256-dimensional vector\nIf we have a batch size of 8 with 4 tokens each, this results in a 8 x 4 x 256 tensor:\nGPT-2 uses absolute position embeddings, so we just create another embedding layer:\nTo create the input embeddings used in an LLM, we simply add the token and the positional embeddings:\nIn the initial phase of the input processing workflow, the input text is segmented into separate tokens\nFollowing this segmentation, these tokens are transformed into token IDs based on a predefined vocabulary: Summary and takeaways See the ./dataloader.ipynb code notebook, which is a concise version of the data loader that we implemented in this chapter and will need for training the GPT model in upcoming chapters.\nSee ./exercise-solutions.ipynb for the exercise solutions.\n","date":"2024-11-29T00:16:47+08:00","permalink":"https://CarlossQAQ.github.io/p/llm-lecture1/","title":"LLM LECTURE1"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887â€¦$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://CarlossQAQ.github.io/p/math-typesetting/","title":"Math Typesetting"}]